#!/usr/bin/ruby

require 'rubygems'
require 'bundler/setup'

require 'inifile'
require 'amqp'

STDOUT.sync = true
STDERR.sync = true

if ARGV[0].nil?
    $stderr.puts "No arguments provided. Please provide path to confiuration file."
    exit 1
end

conf = IniFile.load("/etc/skynet/skynet.conf") || IniFile.new
conf = conf.merge(IniFile.load(ARGV[0]))

amqp_host, amqp_port = ( conf["boss"]["amqp_host"] || "127.0.0.1:5672" ).split(":")
user = conf["boss"]["amqp_user"] || "boss"
pass = conf["boss"]["amqp_pwd"]  || "boss"
vhost = conf["boss"]["amqp_vhost"] || "boss"
db_path = conf["boss"]["db_path"] || "/var/spool/boss/boss_ruote_db"
port = Integer(conf["boss"]["viewer_port"]) || 9292
bind = conf["boss"]["viewer_address"] || "127.0.0.1"
hprio = conf["boss"]["high_priority"] || "high"
pname = ENV["SUPERVISOR_PROCESS_NAME"] || "boss_0" 
$pnum = pname.split("_")[1].to_i

AMQP.settings[:host] = amqp_host
AMQP.settings[:port] = Integer(amqp_port)
AMQP.settings[:user] = user
AMQP.settings[:pass] = pass
AMQP.settings[:vhost] = vhost
#AMQP.logging = true

#test connection
begin
  AMQP.start() do |connection|
    AMQP::Channel.new(connection) do |channel|
      $stderr.puts "Connection opened ok"
      AMQP.stop { EventMachine.stop }
    end
  end
rescue AMQP::Error => e
  $stderr.puts "Failed to connect to AMQP server, error was :"
  $stderr.puts e.message
  $stderr.puts "Please check that the settings in /etc/skynet/skynet.conf are correct."
  $stderr.puts "Run the following commands as root on the AMQP server :"
  $stderr.puts "/usr/sbin/rabbitmqctl add_vhost #{vhost}"
  $stderr.puts "/usr/sbin/rabbitmqctl add_user #{user} #{pass}"
  $stderr.puts "/usr/sbin/rabbitmqctl set_permissions -p #{vhost} #{user} '.*' '.*' '.*'"
  exit 1
end


require 'amqp'
require 'yajl'
require 'ruote'
require 'ruote/storage/fs_storage'
require 'ruote-amqp'
require 'ruote-kit'

require 'pp'

# TODO: move the classes to a different file/module?

module Ruote
  class BOSSStorage < Ruote::FsStorage

    attr_reader :number

    def initialize(dir, options={})

      @number = options.fetch("number", 0)
      super(dir, options)
    end

    def prepare_msg_doc(action, options)

      # merge! is way faster than merge (no object creation probably)

      @counter ||= 0
      begin
        priority = options["workitem"]["fields"]["priority"]
      rescue
        priority = "normal"

      end

      t = Time.now.utc
      ts = "#{t.strftime('%Y-%m-%d')}!#{t.to_i}.#{'%06d' % t.usec}"
      _id = "#{$$}!#{Thread.current.object_id}!#{priority}!#{ts}!#{'%03d' % @counter}"

      @counter = (@counter + 1) % 1000
        # some platforms (windows) have shallow usecs, so adding that counter...

      msg = options.merge!('type' => 'msgs', '_id' => _id, 'action' => action)

      msg.delete('_rev')
        # in case of message replay

      msg
    end

    def get_msgs (limit, priority)

      msgs = get_many('msgs', priority, {:limit => limit, :noblock => true, :skip => limit * @number})
      msgs = get_many('msgs', nil, {:limit => limit, :noblock => true, :skip => limit * @number}) if msgs.empty? 
      msgs.sort_by { |d| d['put_at'] }

    end

  end

  class BOSSWorker < Ruote::Worker

    attr_reader :priority
    attr_reader :number

    def initialize(storage=nil, options={})

      @priority = options.fetch("priority", "high")
      @number = options.fetch("number", 0)
      @roles = options.fetch("roles", ["scheduler", "worker"])

      super(storage)

    end

    def process_msgs

      @msgs = @storage.get_msgs(1, @priority) if @msgs.empty?

      while @msg = @msgs.pop

          r = process(@msg)

          if r != false
            @processed_msgs += 1
          end

          break if Time.now.utc - @last_time >= 0.8

      end
    end

    def step

      begin_step

      @msg = nil
      @processed_msgs = 0

      determine_state

      if @state == 'stopped'
        return
      elsif @state == 'running'
        process_schedules if @roles.include? 'scheduler'
        process_msgs if @roles.include? 'worker'
      end

      take_a_rest # 'running' or 'paused'

    rescue => err

      handle_step_error(err, @msg) # msg may be nil
    end

  end
end

class BOSSReceiver < Ruote::Amqp::Receiver

    #TODO: implement standard logger and error notifier instead of per process
    # specific code
end

@em = Thread.new { EM.run {} }
sleep 0.5

receivers = []
storage = Ruote::BOSSStorage.new(db_path, { :number => $pnum })

if $pnum == 0 
  scheduler = Ruote::BOSSWorker.new(storage, { "number" => $pnum, "priority" => hprio, "roles" => ["scheduler"] })
else
  worker = Ruote::BOSSWorker.new(storage, { "number" => $pnum, "priority" => hprio, "roles" => ["worker"] })
end

# creating the dashboard with a storage context will start all workers
# each in its own thread
$dashboard = Ruote::Dashboard.new(storage)
$stderr.puts "Dashboard threads running"
if conf["boss"]["debug"] == "true"
  $dashboard.noisy = true
end

channel = AMQP::Channel.new($connection)
channel.prefetch(1)
queue = AMQP::Queue.new(channel, 'ruote_workitems', :durable => 1)
receiver = BOSSReceiver.new($dashboard, queue, { "number" => $pnum, "priority" => hprio })

# A simple LocalParticipant to handle registering a new AMQP Participant
#
# fields["name"] : the participant name to be registered
# fields["queue"] : the corresponding amqp queue
#
# boss_register [:action => 'unregister']
#
class BOSSRegistrar
  include Ruote::LocalParticipant
  def consume(workitem)
    if workitem.params["action"] == "unregister"
      $stderr.puts "UnRegister participant :", workitem.fields["name"]
      $dashboard.unregister_participant(workitem.fields["name"])
    else
      $stderr.puts "Register participant :", workitem.fields["name"]
      $stderr.puts "using queue ", workitem.fields["queue"]
      $dashboard.register_participant(workitem.fields["name"],
                                      Ruote::Amqp::Participant,
                                      :routing_key => workitem.fields["queue"],
                                      :position => -2 )
    end
    reply_to_engine(workitem)
  end
end

$dashboard.register_participant 'boss_register', BOSSRegistrar, :position => 'first'

RuoteKit.bind_engine(storage)

RuoteKit.engine.register :clear => false do
  # register forces 'override' to false, but postion 'over' overrides that
  # and if matching key ('.+' for catchall) is not in list, it goes to last
  catchall Ruote::StorageParticipant, {'position' => 'over'}
end

class BossViewer < RuoteKit::Application

  # disable sinatra traps of INT and TERM
  disable :traps

  # Override and extend the class method so we can shutdown the engine
  def BossViewer.quit!

    puts "\nstopping engine"
    RuoteKit.engine.shutdown
    RuoteKit.engine.join
    puts "engine stopped"

    super
  end
  get('/') do
    redirect to('/_ruote/')
  end
end

if $pnum == 0
  @web_server_thread = Thread.start do

    BossViewer.run!(options={
      :bind => bind,
      :port => port,
      :logging => true
    })
  end
end

shutdown = proc {
  $stderr.puts "Shutdown requested by user"

  receiver.shutdown

  $stderr.puts "Receiver shutdown"

  AMQP.stop { EventMachine.stop }
  $stderr.puts "AMQP stopped"

  $dashboard.shutdown

  if $pnum == 0
    BossViewer.quit!
  end

}

memdebug = proc {
  $stderr.puts "Objects after GC"
  ObjectSpace.garbage_collect
  pp ObjectSpace.count_objects
  File.open('/tmp/objids', 'w+') { |file|
    ObjectSpace.each_object() { |obj|
      file.write(pp(obj))
    }
  }
  $stderr.puts "Done"
}


Signal.trap('SIGTERM', shutdown) 
Signal.trap('SIGINT', shutdown) 
Signal.trap('SIGUSR1', memdebug)
$dashboard.join
$stderr.puts "Dashboard shutdown"
if $pnum == 0
  @web_server_thread.join
end

exit 0
