#!/usr/bin/ruby

require 'rubygems'
require 'bundler/setup'

require 'inifile'
require 'amqp'

STDOUT.sync = true

if ARGV[0].nil?
    $stderr.puts "No arguments provided. Please provide path to confiuration file."
    exit 1
end

conf = IniFile.load("/etc/skynet/skynet.conf") || IniFile.new
conf = conf.merge(IniFile.load(ARGV[0]))

amqp_host, amqp_port = ( conf["boss"]["amqp_host"] || "127.0.0.1:5672" ).split(":")
user = conf["boss"]["amqp_user"] || "boss"
pass = conf["boss"]["amqp_pwd"]  || "boss"
vhost = conf["boss"]["amqp_vhost"] || "boss"
db_path = conf["boss"]["db_path"] || "/var/spool/boss/boss_ruote_db"

threads = {}
begin
  t = conf["boss"]["threads"].split(',')
  t.each { |item|
    prio, num = item.split(':')
    threads[prio.to_s] = num.to_i
  }
rescue
  threads = {"low" => 1, "normal" => 1}
end

#db_type

AMQP.settings[:host] = amqp_host
AMQP.settings[:port] = Integer(amqp_port)
AMQP.settings[:user] = user
AMQP.settings[:pass] = pass
AMQP.settings[:vhost] = vhost
#AMQP.logging = true

#test connection
begin
  AMQP.start() do |connection|
    AMQP::Channel.new(connection) do |channel|
      $stderr.puts "Connection opened ok"
      AMQP.stop { EventMachine.stop }
    end
  end
rescue AMQP::Error => e
  $stderr.puts "Failed to connect to AMQP server, error was :"
  $stderr.puts e.message
  $stderr.puts "Please check that the settings in /etc/skynet/skynet.conf are correct."
  $stderr.puts "Run the following commands as root on the AMQP server :"
  $stderr.puts "/usr/sbin/rabbitmqctl add_vhost #{vhost}"
  $stderr.puts "/usr/sbin/rabbitmqctl add_user #{user} #{pass}"
  $stderr.puts "/usr/sbin/rabbitmqctl set_permissions -p #{vhost} #{user} '.*' '.*' '.*'"
  exit 1
end


require 'amqp'
require 'yajl'
require 'ruote'
require 'ruote/storage/fs_storage'
require 'ruote-amqp'
require 'pp'

# custom RuoteAmqp Receiver and Ruote Worker with priority handling
# custom Ruote FsStorage that gets configurable number of msgs at a time
# TODO: move the classes to a different file/module?

module Ruote
  class BOSSStorage < Ruote::FsStorage

    def prepare_msg_doc(action, options)

      # merge! is way faster than merge (no object creation probably)

      @counter ||= 0
      begin
        priority = options["workitem"]["fields"]["priority"]
      rescue
        priority = "normal"

      end

      t = Time.now.utc
      ts = "#{t.strftime('%Y-%m-%d')}!#{t.to_i}.#{'%06d' % t.usec}"
      _id = "#{$$}!#{Thread.current.object_id}!#{priority}!#{ts}!#{'%03d' % @counter}"

      @counter = (@counter + 1) % 1000
        # some platforms (windows) have shallow usecs, so adding that counter...

      msg = options.merge!('type' => 'msgs', '_id' => _id, 'action' => action)

      msg.delete('_rev')
        # in case of message replay

      msg
    end

    def get_msgs (limit, priority)

      msgs = get_many('msgs', priority, {:limit => limit, :noblock => true})
      msgs = get_many('msgs', nil, {:limit => limit, :noblock => true}) if msgs.empty? 
      msgs.sort_by { |d| d['put_at'] }

    end

  end

  class BOSSWorker < Ruote::Worker

    attr_reader :priority
    attr_reader :number

    def initialize(storage=nil, options={})

      @priority = options.fetch("priority", "normal")
      @number = options.fetch("number", 0)

      super(storage)

    end

    def can_handle(msg)
      begin
        msg["workitem"]["fields"].fetch("priority") == @priority
      rescue 
        true
      end

    end

    def process_msgs

      @msgs = @storage.get_msgs(10, @priority) if @msgs.empty?

      collisions = 0

      while @msg = @msgs.shift

        #if can_handle(@msg)

          $stderr.puts "handling #{@msg['_id']}"

          r = process(@msg)

          if r != false
            @processed_msgs += 1
          else
            collisions += 1
          end

          if collisions > 2
            @msgs = @msgs[(@msgs.size / 2)..-1] || []
            collisions = 0
          end

          break if Time.now.utc - @last_time >= 0.8

      end
    end

  end
end

class BOSSReceiver < Ruote::Amqp::Receiver

    attr_reader :number
    attr_reader :priority

    def initialize(engine_or_storage, queue, options={})

      @number = options.fetch("number", 0)
      @priority = options.fetch("priority", "normal")

      super

    end

    def can_handle(item)

        @priority == item['fields'].fetch("priority", "normal")

    end

    def handle(header, payload)

      item = decode_message(header, payload)

      if item['error'] && item['fei']

        flunk(item)
        header.ack

      elsif item['fields'] && item['fei']

        receive(item)
        header.ack

      elsif item['process_definition'] || item['definition']

        launch(item)
        header.ack

      else

        raise ArgumentError.new("cannot receive or launch #{item.inspect}")

      end

    rescue => e

      handle_error(e)
      header.reject

    end

    #TODO: implement standard logger and error notifier instead of per process
    # specific code
end

@em = Thread.new { EM.run {} }
sleep 0.5

receivers = []
storage = Ruote::BOSSStorage.new(db_path)

threads.each_pair { |prio, i|
  i.times { |c|

    # each worker takes a storage context and will start in its own thread
    # when dashboard is initialized
    worker = Ruote::BOSSWorker.new(storage, { "number" => c, "priority" => prio })
  }
}

# creating the dashboard with a storage context will start all workers
# each in its own thread
$dashboard = Ruote::Dashboard.new(storage)
$stderr.puts "Dashboard threads running"
if conf["boss"]["debug"] == "true"
  $dashboard.noisy = true
end

# Starting multiple receiver threads performs better than a single one
threads.each_pair { |prio, i|
  i.times { |c|

    channel = AMQP::Channel.new($connection)
    channel.prefetch(1)
    queue = AMQP::Queue.new(channel, 'ruote_workitems', :durable => 1)
    receivers << BOSSReceiver.new($dashboard, queue, { "number" => c, "priority" => prio })

    sleep 0.2
  }
}

# A simple LocalParticipant to handle registering a new AMQP Participant
#
# fields["name"] : the participant name to be registered
# fields["queue"] : the corresponding amqp queue
#
# boss_register [:action => 'unregister']
#
class BOSSRegistrar
  include Ruote::LocalParticipant
  def consume(workitem)
    if workitem.params["action"] == "unregister"
      $stderr.puts "UnRegister participant :", workitem.fields["name"]
      $dashboard.unregister_participant(workitem.fields["name"])
    else
      $stderr.puts "Register participant :", workitem.fields["name"]
      $stderr.puts "using queue ", workitem.fields["queue"]
      $dashboard.register_participant(workitem.fields["name"],
                                      Ruote::Amqp::Participant,
                                      :routing_key => workitem.fields["queue"],
                                      :position => -2 )
    end
    reply_to_engine(workitem)
  end
end

$dashboard.register_participant 'boss_register', BOSSRegistrar, :position => 'first'

shutdown = proc {
  $stderr.puts "Shutdown requested by user"

  receivers.each { |rcvr|
    rcvr.shutdown
  }
  $stderr.puts "Receivers shutdown"

  AMQP.stop { EventMachine.stop }
  $stderr.puts "AMQP stopped"

  $dashboard.shutdown
}

memdebug = proc {
  $stderr.puts "Objects after GC"
  ObjectSpace.garbage_collect
  pp ObjectSpace.count_objects
  File.open('/tmp/objids', 'w+') { |file|
    ObjectSpace.each_object() { |obj|
      file.write(pp(obj))
    }
  }
  $stderr.puts "Done"
}


Signal.trap('SIGTERM', shutdown) 
Signal.trap('SIGINT', shutdown) 
Signal.trap('SIGUSR1', memdebug)
$dashboard.join
$stderr.puts "Dashboard shutdown"

exit 0
