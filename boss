#!/usr/bin/ruby

require 'rubygems'
require 'bundler/setup'

require 'inifile'
require 'amqp'

STDOUT.sync = true

if ARGV[0].nil?
    puts "No arguments provided. Please provide path to confiuration file."
    exit 1
end

conf = IniFile.load("/etc/skynet/skynet.conf") || IniFile.new
conf = conf.merge(IniFile.load(ARGV[0]))

amqp_host, amqp_port = ( conf["boss"]["amqp_host"] || "127.0.0.1:5672" ).split(":")
user = conf["boss"]["amqp_user"] || "boss"
pass = conf["boss"]["amqp_pwd"]  || "boss"
vhost = conf["boss"]["amqp_vhost"] || "boss"
db_path = conf["boss"]["db_path"] || "/var/spool/boss/boss_ruote_db"
threads = conf["boss"]["threads"].to_i || 10
#db_type

AMQP.settings[:host] = amqp_host
AMQP.settings[:port] = Integer(amqp_port)
AMQP.settings[:user] = user
AMQP.settings[:pass] = pass
AMQP.settings[:vhost] = vhost
#AMQP.logging = true

#test connection
begin
  AMQP.start() do |connection|
    AMQP::Channel.new(connection) do |channel|
      puts "Connection opened ok"
      AMQP.stop { EventMachine.stop }
    end
  end
rescue AMQP::Error => e
  puts "Failed to connect to AMQP server, error was :"
  puts e.message
  puts "Please check that the settings in /etc/skynet/skynet.conf are correct."
  puts "Run the following commands as root on the AMQP server :"
  puts "/usr/sbin/rabbitmqctl add_vhost #{vhost}"
  puts "/usr/sbin/rabbitmqctl add_user #{user} #{pass}"
  puts "/usr/sbin/rabbitmqctl set_permissions -p #{vhost} #{user} '.*' '.*' '.*'"
  exit 1
end

require 'yajl'
require 'ruote'
require 'ruote/storage/fs_storage'
require 'ruote-amqp'

$dashboard = Ruote::Dashboard.new(
  Ruote::Worker.new(
    Ruote::FsStorage.new(db_path)
  )
)

if conf["boss"]["debug"] == "true"
    $dashboard.noisy = true
end

# A simple LocalParticipant to handle registering a new AMQP Participant
#
# fields["name"] : the participant name to be registered
# fields["queue"] : the corresponding amqp queue
#
# boss_register [:action => 'unregister']
#
class BOSSRegistrar
  include Ruote::LocalParticipant
  def consume(workitem)
    if workitem.params["action"] == "unregister"
      puts "UnRegister participant :", workitem.fields["name"]
      $dashboard.unregister_participant(workitem.fields["name"])
    else
      puts "Register participant :", workitem.fields["name"]
      puts "using queue ", workitem.fields["queue"]
      $dashboard.register_participant(workitem.fields["name"],
                                      Ruote::Amqp::Participant,
                                      :routing_key => workitem.fields["queue"],
                                      :position => -2 )
    end
    reply_to_engine(workitem)
  end
end
$dashboard.register_participant 'boss_register', BOSSRegistrar, :position => 'first'

@em = Thread.new { EM.run {} }
sleep 0.5

tg = ThreadGroup.new
receivers = []
threads.times {
  $channel = AMQP::Channel.new($connection)
  $channel.prefetch(1)
  $queue = AMQP::Queue.new($channel, 'ruote_workitems', :durable => 1)
  receiver = Ruote::Amqp::Receiver.new($dashboard, $queue)
  receivers << receiver
  t = Thread.new { receiver.join }
  t.run
  tg.add(t)
  sleep 0.2
}

tg.list.each { |t|
  puts "foo"
  puts t.status
}

shutdown = proc {
  puts 'Shutdown gracefully'
  receivers.each { |rcvr|
    rcvr.shutdown
  }
  $dashboard.shutdown!
}

# We run under supervisor and it communicates via signals
Signal.trap('SIGTERM', shutdown) 
Signal.trap('SIGINT', shutdown) 

# All setup... wait for a shutdown
puts "Dashboard running"
$dashboard.join

puts "Dashboard shutdown"
tg.list.each { |t|
  t.join
}

AMQP.stop { EventMachine.stop }
puts "AMQP stopped"

exit 0
