#!/usr/bin/ruby

require 'rubygems'
require 'bundler/setup'

require 'inifile'
require 'amqp'

STDOUT.sync = true
STDERR.sync = true

if ARGV[0].nil?
    $stderr.puts "No arguments provided. Please provide path to confiuration file."
    exit 1
end

conf = IniFile.load("/etc/skynet/skynet.conf") || IniFile.new
conf = conf.merge(IniFile.load(ARGV[0]))

amqp_host, amqp_port = ( conf["boss"]["amqp_host"] || "127.0.0.1:5672" ).split(":")
user = conf["boss"]["amqp_user"] || "boss"
pass = conf["boss"]["amqp_pwd"]  || "boss"
vhost = conf["boss"]["amqp_vhost"] || "boss"
db_path = conf["boss"]["db_path"] || "/var/spool/boss/boss_ruote_db"
#db_type

AMQP.settings[:host] = amqp_host
AMQP.settings[:port] = Integer(amqp_port)
AMQP.settings[:user] = user
AMQP.settings[:pass] = pass
AMQP.settings[:vhost] = vhost
#AMQP.logging = true

#test connection
begin
  AMQP.start() do |connection|
    AMQP::Channel.new(connection) do |channel|
      $stderr.puts "Connection opened ok"
      AMQP.stop { EventMachine.stop }
    end
  end
rescue AMQP::Error => e
  $stderr.puts "Failed to connect to AMQP server, error was :"
  $stderr.puts e.message
  $stderr.puts "Please check that the settings in /etc/skynet/skynet.conf are correct."
  $stderr.puts "Run the following commands as root on the AMQP server :"
  $stderr.puts "/usr/sbin/rabbitmqctl add_vhost #{vhost}"
  $stderr.puts "/usr/sbin/rabbitmqctl add_user #{user} #{pass}"
  $stderr.puts "/usr/sbin/rabbitmqctl set_permissions -p #{vhost} #{user} '.*' '.*' '.*'"
  exit 1
end

require 'yajl'
require 'ruote'
require 'ruote/storage/fs_storage'
require 'ruote-amqp'

$dashboard = Ruote::Dashboard.new(
  Ruote::Worker.new(
    Ruote::FsStorage.new(db_path)
  )
)

if conf["boss"]["debug"] == "true"
    $dashboard.noisy = true
end

# A simple LocalParticipant to handle registering a new AMQP Participant
#
# fields["name"] : the participant name to be registered
# fields["queue"] : the corresponding amqp queue
#
# boss_register [:action => 'unregister']
#
class BOSSRegistrar
  include Ruote::LocalParticipant
  def consume(workitem)
    if workitem.params["action"] == "unregister"
      $stderr.puts "UnRegister participant :", workitem.fields["name"]
      $dashboard.unregister_participant(workitem.fields["name"])
    else
      $stderr.puts "Register participant :", workitem.fields["name"]
      $stderr.puts "using queue ", workitem.fields["queue"]
      $dashboard.register_participant(workitem.fields["name"],
                                      Ruote::Amqp::Participant,
                                      :routing_key => workitem.fields["queue"],
                                      :position => -2 )
    end
    reply_to_engine(workitem)
  end
end

@em = Thread.new { EM.run {} }
sleep 0.5

$channel = AMQP::Channel.new($connection)
$queue = AMQP::Queue.new($channel, 'ruote_workitems')
receiver = Ruote::Amqp::Receiver.new($dashboard, $queue)
$dashboard.register_participant 'boss_register', BOSSRegistrar, :position => 'first'

shutdown = proc {
  $stderr.puts 'Shutdown gracefully'
  $dashboard.shutdown!
}

# We run under supervisor and it communicates via signals
Signal.trap('SIGTERM', shutdown) 
Signal.trap('SIGINT', shutdown) 

# All setup... wait for a shutdown
$stderr.puts "Dashboard running"
$dashboard.join()
$stderr.puts "Dashboard shutdown"
receiver.shutdown()
AMQP.stop { EventMachine.stop }
$stderr.puts "AMQP stopped"

exit 0
