#!/usr/bin/ruby

require 'rubygems'
require 'bundler/setup'

require 'inifile'
require 'amqp'

STDOUT.sync = true

if ARGV[0].nil?
    puts "No arguments provided. Please provide path to confiuration file."
    exit 1
end

conf = IniFile.load("/etc/skynet/skynet.conf") || IniFile.new
conf = conf.merge(IniFile.load(ARGV[0]))

amqp_host, amqp_port = ( conf["boss"]["amqp_host"] || "127.0.0.1:5672" ).split(":")
user = conf["boss"]["amqp_user"] || "boss"
pass = conf["boss"]["amqp_pwd"]  || "boss"
vhost = conf["boss"]["amqp_vhost"] || "boss"
db_path = conf["boss"]["db_path"] || "/var/spool/boss/boss_ruote_db"

threads = {}
begin
  t = conf["boss"]["threads"].split(',')
  t.each { |item|
    prio, num = item.split(':')
    threads[prio.to_s] = num.to_i
  }
rescue
  threads = {"low" => 1, "normal" => 1}
end

#db_type

AMQP.settings[:host] = amqp_host
AMQP.settings[:port] = Integer(amqp_port)
AMQP.settings[:user] = user
AMQP.settings[:pass] = pass
AMQP.settings[:vhost] = vhost
#AMQP.logging = true

#test connection
begin
  AMQP.start() do |connection|
    AMQP::Channel.new(connection) do |channel|
      puts "Connection opened ok"
      AMQP.stop { EventMachine.stop }
    end
  end
rescue AMQP::Error => e
  puts "Failed to connect to AMQP server, error was :"
  puts e.message
  puts "Please check that the settings in /etc/skynet/skynet.conf are correct."
  puts "Run the following commands as root on the AMQP server :"
  puts "/usr/sbin/rabbitmqctl add_vhost #{vhost}"
  puts "/usr/sbin/rabbitmqctl add_user #{user} #{pass}"
  puts "/usr/sbin/rabbitmqctl set_permissions -p #{vhost} #{user} '.*' '.*' '.*'"
  exit 1
end


require 'yajl'
require 'ruote'
require 'ruote/storage/fs_storage'
require 'ruote-amqp'

# custom RuoteAmqp Receiver and Ruote Worker with priority handling
# custom Ruote FsStorage that gets 5 msgs only at a time

module Ruote
  class BOSSStorage < Ruote::FsStorage

    def get_msgs

      get_many('msgs', nil, :limit => 2).sort_by { |d| d['put_at'] }
    end

  end

  class BOSSWorker < Ruote::Worker

    attr_reader :priority

    def initialize(storage=nil, options={})

      super(storage)

      @priority = options.fetch("priority", "normal")

    end

    def can_handle(msg)
      begin
        msg["workitem"]["fields"].fetch("priority") == @priority
      rescue 
        true
      end

    end

    def process_msgs

      @msgs = @storage.get_msgs if @msgs.empty?

      collisions = 0

      while @msg = @msgs.shift

        if can_handle(@msg)

          #$stderr.puts "handling #{@msg['_id']}"

          r = process(@msg)

          if r != false
            @processed_msgs += 1
          else
            collisions += 1
          end

          if collisions > 2
            @msgs = @msgs[(@msgs.size / 2)..-1] || []
            collisions = 0
          end

          break if Time.now.utc - @last_time >= 0.8

        else

          #$stderr.puts "can't handle #{@msg['_id']}, skipping"
          
        end

      end
    end

  end
end

class BOSSReceiver < Ruote::Amqp::Receiver

    attr_reader :number
    attr_reader :priority

    def initialize(engine_or_storage, queue, options={})

      @number = options.fetch("number", 0)
      @priority = options.fetch("priority", "normal")

      super

    end

    def can_handle(item)

        @priority == item['fields'].fetch("priority", "normal")

    end

    def handle(header, payload)

      item = decode_message(header, payload)

      if item['error'] && item['fei']

        #puts "Error #{item['fei']}"
        flunk(item)
        header.ack

      elsif item['fields'] && item['fei']

        if can_handle(item)

          #puts "Receive #{item['fei']}"
          receive(item)
          header.ack

        else

          #puts "Reject #{item['fei']}, can't handle it"
          header.reject({:requeue => true})

        end

      elsif item['process_definition'] || item['definition']

        #puts "Launch item #{item['fei']}"
        launch(item)
        header.ack

      else

        raise ArgumentError.new("cannot receive or launch #{item.inspect}")

      end

    rescue => e

      handle_error(e)
      header.reject

    end

end


@em = Thread.new { EM.run {} }
sleep 0.5

$dashboards = []
receivers = []
storage = Ruote::BOSSStorage.new(db_path)

threads.each_pair { |prio, i|
  i.times { |c|

    worker = Ruote::BOSSWorker.new(storage, { "priority" => prio })
    dashboard = Ruote::Dashboard.new(worker)

    if conf["boss"]["debug"] == "true"
      dashboard.noisy = true
    end

    channel = AMQP::Channel.new($connection)
    channel.prefetch(1)
    queue = AMQP::Queue.new(channel, 'ruote_workitems', :durable => 1)
    receivers << BOSSReceiver.new(dashboard, queue, { "number" => c, "priority" => prio })

    $dashboards << dashboard
    sleep 0.2
  }
}

shutdown = proc {
  puts "Shutdown requested by user"
  $dashboards.first.shutdown
}

Signal.trap('SIGTERM', shutdown) 
Signal.trap('SIGINT', shutdown) 

# A simple LocalParticipant to handle registering a new AMQP Participant
#
# fields["name"] : the participant name to be registered
# fields["queue"] : the corresponding amqp queue
#
# boss_register [:action => 'unregister']
#
class BOSSRegistrar
  include Ruote::LocalParticipant
  def consume(workitem)
    if workitem.params["action"] == "unregister"
      puts "UnRegister participant :", workitem.fields["name"]
      $dashboards.first.unregister_participant(workitem.fields["name"])
    else
      puts "Register participant :", workitem.fields["name"]
      puts "using queue ", workitem.fields["queue"]
      $dashboards.first.register_participant(workitem.fields["name"],
                                      Ruote::Amqp::Participant,
                                      :routing_key => workitem.fields["queue"],
                                      :position => -2 )
    end
    reply_to_engine(workitem)
  end
end

$dashboards.first.register_participant 'boss_register', BOSSRegistrar, :position => 'first'

# TODO: A simple LocalParticipant to handle error logging
# instead of custom code added to every process

puts "Dashboard threads running"
$dashboards.first.join
puts "Dashboard shutdown"

receivers.each { |rcvr|
  rcvr.shutdown
}

$dashboards.each { |dbrd|
  dbrd.shutdown
}

AMQP.stop { EventMachine.stop }
puts "AMQP stopped"

exit 0
